AWSTemplateFormatVersion: '2010-09-09'
Parameters: {}
Description: GraphQL Api for Gator
Resources:
  GraphQLApi:
    Type: "AWS::AppSync::GraphQLApi"
    Properties:
      Name: GraphQL API
      AuthenticationType: AWS_IAM

  DBDataSource:
    Type: "AWS::AppSync::DataSource"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: DBTable
      Description: Data source to get data from
      Type: AMAZON_DYNAMODB
      ServiceRoleArn: !GetAtt 'LambdaReadAllDataRole.Arn'
      DynamoDBConfig:
        AwsRegion: !Ref AWS::Region
        TableName: !Ref data

  Gunzipper:
    Type: AWS::Lambda::Function
    Properties:
      Code:
        ZipFile: >
          const zlib = require('zlib');
          exports.handler = async (event) => {
              return new Promise( (resolve,reject) => {
                  zlib.inflate(new Buffer(event.data,'binary'), (err,result) => {
                      if (err) {
                          return reject(err);
                      }
                      return resolve(result.toString('utf8'));
                  });
              }).then( inflated => {
                  return {
                      statusCode: 200,
                      body: JSON.parse(inflated),
                  }
              });
          };
      Description: Gunzipper
      Handler: index.handler
      Role: !GetAtt 'LambdaGunzipperRole.Arn'
      Runtime: nodejs8.10
      MemorySize: 128
      Timeout: 10
  LambdaGunzipperRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
  AppSyncGunzipperRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: appsync.amazonaws.com
            Action: sts:AssumeRole
      Policies:
        - PolicyName: AppSyncExecutionPolicy
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: Allow
                Action:
                  - "lambda:InvokeFunction"
                Resource: !GetAtt Gunzipper.Arn
  GunzipperDataSource:
    Type: AWS::AppSync::DataSource
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: 'Gunzipper'
      Description: 'Gunzipper for data'
      Type: "AWS_LAMBDA"
      ServiceRoleArn: !GetAtt AppSyncGunzipperRole.Arn
      LambdaConfig:
        LambdaFunctionArn: !GetAtt Gunzipper.Arn
  DatasetAuthoriser:
    Type: "AWS::AppSync::FunctionConfiguration"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: DatasetAuthoriser
      Description: Authoriser for datasets
      DataSourceName: !GetAtt DBDataSource.Name
      FunctionVersion: '2018-05-29'
      RequestMappingTemplate: |
        {
          "version" : "2017-02-28",
          "operation" : "Query",
          "query" : {
            "expression": "dataset = :dataset and acc = :acc",
            "expressionValues" : {
              ":dataset" : $util.dynamodb.toDynamoDBJson($ctx.stash.dataset),
              ":acc" : $util.dynamodb.toDynamoDBJson("metadata")
            }
          }
        }
      ResponseMappingTemplate: |
        #set ($grants = $ctx.stash.grants )
        #set ($dataset = $ctx.stash.dataset )
        #set ($groupids = $ctx.result.items[0]["group_ids"])
        #set ($anymatch = 0)
        #set ($testedkeys = [])
        #set ($testedpatterns = [])
        $util.qr($testedkeys.add('START'))
        $util.qr($testedpaterns.add('START'))
        #foreach ($grant in $grants.entrySet())
          $util.qr($testedkeys.add($grant.key))
          #foreach ($groupid in $groupids)
              $util.qr($testedpatterns.add("${groupid}/${dataset}"))
              $util.qr($testedpatterns.add("${groupid}/*"))
              #if ($grant.key == "${groupid}/${dataset}" || $grant.key == "${groupid}/*" )
                #set( $anymatch = 1)
              #end
          #end
        #end
        #if ($anymatch == 0)
          ## Bail out if no matches for dataset
          $util.unauthorized()
        #end
        $util.qr($ctx.stash.put("mime", $ctx.result.items[0].metadata.mimetype))
        $util.qr($ctx.stash.put("locations", $ctx.result.items[0].metadata.locations))
        $util.qr($ctx.stash.put("groupids", $groupids))
        $util.qr($ctx.stash.put("testedkeys", $testedkeys))
        $util.qr($ctx.stash.put("testedpatterns", $testedpatterns))
        {}
  DataResolver:
    Type: "AWS::AppSync::Resolver"
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: DataItem
      FieldName: data
      DataSourceName: !GetAtt GunzipperDataSource.Name
      RequestMappingTemplate: |
        $util.qr($ctx.stash.put("mime", $ctx.source.mimetype))
        $util.qr($ctx.stash.put("locations", $ctx.source.locations))
        {
          "version" : "2017-02-28",
          "operation": "Invoke",
          "payload": $util.toJson($context.source)
        }
      ResponseMappingTemplate: |
        #if( $ctx.stash.mime == 'application/json+slim_expression')
          #set($newresults = [])
          #set($size = $context.result.body.size())
          #set( $locationcount = $size / 2 )
          #set( $locationcount = $locationcount - 1 )
          #foreach($index in [0..$locationcount])
            #set($map = {})
              $util.qr( $map.put("__typename","SlimExpression"))
              #set( $locindex = 2 * $index )
              #set( $valindex = $locindex + 1 )
              $util.qr( $map.put("location", $ctx.stash.locations.get($ctx.result.body.get($locindex)).description ))
              $util.qr( $map.put("tissue", $ctx.stash.locations.get($ctx.result.body.get($locindex)).simple_tissue ))
              $util.qr( $map.put("value", $ctx.result.body.get($valindex)))
              #if ( $ctx.arguments.filter.location )
                #if ( $map.location.toLowerCase().contains($ctx.arguments.filter.location.toLowerCase()) )
                  $util.qr($newresults.add($map))
                #end
              #else
                $util.qr($newresults.add($map))
              #end
          #end
          $util.qr($ctx.result.put("body",$newresults))
        #else
          #foreach ($result in $context.result.body)
            #if( $ctx.stash.mime == 'application/json+glycodomain')
              #set( $ignore = $result.put("__typename", "Domains"))
            #elseif( $ctx.stash.mime == 'application/json+msdata')
              #set( $ignore = $result.put("__typename", "MsData"))
            #end
          #end
        #end
        $util.toJson($context.result.body)
  QueryAllPostResolver:
    Type: "AWS::AppSync::Resolver"
    DependsOn: Schema
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      TypeName: Query
      FieldName: getAccs
      Kind: PIPELINE
      PipelineConfig:
        Functions:
          - !GetAtt DatasetAuthoriser.FunctionId
          - !GetAtt MultipleAccRetriever.FunctionId
      RequestMappingTemplate: |
        $util.qr($ctx.stash.put("accs", $ctx.args.accs))
        $util.qr($ctx.stash.put("dataset", $ctx.args.dataset))
        $util.qr($ctx.stash.put("grants", $util.parseJson($ctx.request.headers.grants)))
        {}
      ResponseMappingTemplate: |
        $util.toJson($ctx.result)
  MultipleAccRetriever:
    Type: "AWS::AppSync::FunctionConfiguration"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Name: QueryAllPostResolver
      Description: Get multiple accs for dataset
      DataSourceName: !GetAtt DBDataSource.Name
      FunctionVersion: '2018-05-29'
      RequestMappingTemplate: |
        #set($ids = [])
        #foreach($id in ${ctx.args.accs})
          #set($map = {})
          $util.qr($map.put("acc", $util.dynamodb.toString($id)))
          $util.qr($map.put("dataset", $util.dynamodb.toString($ctx.args.dataset)))
          $util.qr($ids.add($map))
        #end
        {
            "version" : "2018-05-29",
            "operation" : "BatchGetItem",
            "tables" : {
                "test-data": {
                    "keys": $util.toJson($ids),
                    "consistentRead": true
                }
            }
        }
      ResponseMappingTemplate: !Sub |
        #foreach ($result in $ctx.result.data["${data}"])
          ## Extract type name from the id field.
          $util.qr($result.put("mimetype",$ctx.stash.mime))
          $util.qr($result.put("locations",$ctx.stash.locations))
        #end
        #set( $unprocessed = [] )
        #foreach ($unprocessed in $ctx.result.unprocessedKeys["${data}"])
          $util.qr( $unprocessed.add($unprocessed.acc))
        #end
        $util.toJson({ "items" : $ctx.result.data["${data}"], "dataset" : $ctx.args.dataset, "unprocessed" : $unprocessed })
  Schema:
    Type: "AWS::AppSync::GraphQLSchema"
    Properties:
      ApiId: !GetAtt GraphQLApi.ApiId
      Definition: |
        union DataTypes = MsData | Domains | SlimExpression

        input DataFilter {
          location: String
        }

        type Domains {
          start: Int
          end: Int
          dom: String
        }

        type MsData {
          acc: String
          peptide_start: Int
          peptide_end: Int
          sites: [[String]]
          composition: [String]
        }

        type SlimExpression {
          location: String
          value: Float
          tissue: String
        }

        type Query {
          getTestData(acc: String!, dataset: String!): DataItem
          listTestData(acc: String!, datasets: [String], nextToken: String): DataItemSet
          getAccs(accs: [String]!, dataset: String): DataItemSet
        }

        type DataItem {
          acc: String!
          dataset: String
          data(filter: DataFilter): [DataTypes]
        }

        type DataItemSet {
          items: [DataItem]
          nextToken: String
          unprocessed: [String]
        }